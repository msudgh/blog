<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html lang="fa" class="no-js">
<!--<![endif]-->

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>نسخه آنلاین | کتاب Node.js برای مبتدی‌ها</title>
        <meta name="description" content="" />
        <link rel="icon" href="../favicon.png" type="image/png">
        <link rel="stylesheet" type="text/css" href="app.css" />
        <script src="js/modernizr.custom.79639.js"></script>
    </head>
    <body>
        <div id="container" class="container">

            <div class="menu-panel">
                <h3>فهرست مطالب</h3>
                <ul id="menu-toc" class="menu-toc">
                    <li class="menu-toc-current"><a href="#item1">صفحه نخست</a></li>
                    <li><a href="#item2">نکته ویژه</a></li>
                    <li><a href="#item3">پیشگفتار</a></li>
                    <li><a href="#item4">جاوااسکریپت و Node.js</a></li>
                    <li><a href="#item5">یک برنامه کامل تحت وب به کمک Node.js</a></li>
                    <li><a href="#item6">پیاده سازی برنامه - بخش ۱</a></li>
					<li><a href="#item7">پیاده سازی برنامه - بخش ۲</a></li>
                    <li><a href="#item8">نتیجه‌گیری و چشم انداز</a></li>
                </ul>
            </div>

            <div class="bb-custom-wrapper">
                <div id="bb-bookblock" class="bb-bookblock">
                    <div class="bb-item" id="item1">
                        <div class="content">
                            <div class="scroller">
                                <h2>صفحه نخست</h2>
                                <div class="page">
                                    <h1 style="font-size: 2.2em;font-family:'iran', arial;">Node برای مبتدی‌ها</h1>
                                    <h3>آموزش جامع Node.js</h3>
                                    <br>
                                    <p>هدف کلی این کتاب آشنا کردن شما با توسعه نرم‌افزار به‌وسیله Node.js و فراگیری مباحث مهم برنامه‌نویسی پیشرفته جاوااسکریپت در یک مسیر 43 صفحه‌ای است. برای سهولت مطالعه این نسخه از کتاب(آنلاین)، عنوان‌بندی فهرست با نسخه pdf متفاوت است اما از نظر محتوا یکی هستند.</p>
                                    <p>دریافت سورس برنامه و نسخه .pdf از طریق:</p>
                                    <ul>
                                        <li><a href="http://msud.ir/nbpersian">http://msud.ir/nbpersian</a>
                                    </ul>
                                    <p>برای همکاری محتوای ترجمه، پیشنهادها و رفع اشکال‌ها می‌توانید در Github دنبال کنید:</p>
                                    <ul>
                                        <li><a href="https://github.com/imasood/nbpersian">https://github.com/imasood/nbpersian</a></li>
                                    </ul>
                                    <br>
                                    <h3 class="head--color">این کتاب را در توییتر به اشتراک بگذارید!</h3>
                                    <p>برای کمک به من و گسترش این کتاب می‌توانید آن را در توییتر یا شبکه‌های اجتماعی دیگر به اشتراک بگذارید.</p>
                                    <p>هشتگ پیشنهادی برای این کتاب: #nodebeginner</p>
                                    <p>با رجوع به لینک زیر می‌توانید اقدام به جستجو هشتگ فوق کنید و گفته‌های دیگران را پیدا کنید:</p>
                                    <ul>
                                        <li><a href="https://twitter.com/hashtag/nodebeginner?src=hash">https://twitter.com/hashtag/nodebeginner?src=hash</a></li>
                                    </ul>
                                    <br>
                                    <h3 class="head--color">مجوز کتاب</h3>
                                    <p>
                                        <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br>
                                        ترجمه فارسی این کتاب تحت مجوز بین‌المللی کرییتیو کامنز بوده(CC BY-NC-ND 4.0) و می‌توانید به رایگان انتشار دهید. به یاد داشته باشید نسخه انگلیسی و موجود در Leanpub تحت مجوز فوق نمی‌باشد.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="bb-item" id="item2">
                        <div class="content">
                            <div class="scroller">
                                <h2>نکته ویژه</h2>
                                <div class="page">
                                    <p>خواننده محترم، این کتاب به‌منظور یادگیری آغازین شما برای توسعه نرم‌افزار به‌وسیله Node.js است، نه کمتر و نه بیشتر.</p>
                                    <p>بسیاری از خوانندگان می‌پرسند که پس از مطالعه این کتاب چه باید کنند که در پاسخ باید گفت به مباحثی همچون مدیریت پایگاه‌های داده، کار با فریم‌ورک‌ها، کار با واحد‌های آزمایش(Unit Test) و مطالب بیشتر بپردازند.</p>
                                    <p>به‌تازگی بر روی کتاب مشابه ای کار کرده‌ام با عنوان The Node Craftsman Book که هم‌اکنون بر روی وب‌سایت انتشارات Leanpub موجود است و به‌صورتبه‌صورت کلی موضوعات زیر را شامل می‌شود:</p>
                                    <ul>
                                        <li>اصول پایه‌ای Node.js</li>
                                        <li>کار با NPM و بسته‌ها(Packages)</li>
                                        <li>توسعه به‌وسیله Node.js بر پایه برنامه‌نویسی آزمون محور(Test-Driven)</li>
                                        <li>برنامه‌نویسی شیءگرا در جاوااسکریپت(OOP)</li>
                                        <li>توسعه به کمک AngularJs</li>
                                        <li>کار با پایگاه‌های داده</li>
                                    </ul>
                                    <p>اگر مایل به دریافت کتاب The Node Craftsman Book هستید می‌توانید به لینک زیر رجوع کنید:</p>
                                    <ul>
                                        <li><a href="http://leanpub.com/nodecraftsman">http://leanpub.com/nodecraftsman</a></li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="bb-item" id="item3">
                        <div class="content">
                            <div class="scroller">
                                <h2>پیشگفتار</h2>
                                <div class="page">
                                    <p>هدف کلی این آموزش آشنا کردن شما با توسعه نرم‌افزار به‌وسیله Node.js است، در طول این آموزش، مباحث موردنیاز برای درک برنامه‌نویسی پیشرفته "جاوااسکریپت" را فرا خواهید گرفت و این آموزش فراتر از مثال "Hello World" خواهد بود.</p>
                                    <p>در حال حاضر شما در حال مطالعه آخرین نسخه از این کتاب هستید و بروز رسانی‌ها شامل مواردی همچون رفع خطاها یا تغییرات جزئی خواهند بود که آخرین بروز رسانی به تاریخ 10 اکتبر، 2015 باز می‌گردد.</p>
                                    <p>نمونه کدهای موجود در این کتاب بر پایه نسخه 0.10.12 از Node.js نوشته و آزمایش شده است.</p>
                                    <br>
                                    <h3 class="head--color">مخاطبان</h3>
                                    <p>این کتاب مسلماً مناسب خوانندگی خواهد بود که پس‌زمینه‌ای نسبت به موضوعات زیر داشته باشند: حداقل آشنایی با یکی از زبان‌های شیء‌گرا همچون Ruby، Python، PHP یا Java. آشنایی کوتاه با جاوااسکریپت و Node.js</p>
                                    <p>کتاب، متمرکز بر توسعه‌دهندگانی است که با مباحث نوع داده(Data Type)، متغیرها، ساختارهای کنترلی و موارد دیگر آشنایی دارند که کتاب شامل این موضوعات نیست. در حال حاضر برای درک بهتر این کتاب به یادگیری موارد فوق نیاز دارید.</p>
                                    <p>هرچند مباحثی همانند توابع و شیء‌ها در جاوااسکریپت با دیگر زبان‌ها متفاوت است اما در این کتاب به توضیح بیشتر و عمیق‌تر آن‌ها خواهیم پرداخت.</p>
                                    <br>
                                    <h3 class="head--color">ساختار کتاب</h3>
                                    <p>پس از مطالعه این کتاب، شما می‌بایست یک برنامه تحت وب ساخته باشید که به کاربران اجازه خواهد داد صفحات را مشاهده کنند و اقدام به آپلود فایل کنند.</p>
                                    <p>البته باید در نظر داشته باشید که این مثال دنیا را تغییر نخواهد داد اما به ما کمک می‌کند که قدم بلندی برداریم و نمی‌خواهیم برنامه‌ای بسازیم که صرفاً در انتها بگوییم به‌اندازه کافی خوب است و به اهداف موردنظر رسیده‌ایم. ساخت این برنامه ساده اما در این حال کامل به ما جنبه‌های مختلف یک برنامه پیشرفته در Node.js را نشان خواهد داد.</p>
                                    <p>ما به دنبال چگونگی توسعه جاوااسکریپت در Node.js هستیم و این فرق دارد با توسعه جاوااسکریپت در مرورگر‌ها.</p>
                                    <p>ابتدا با سُنَت قدیمی نوشتن برنامه "Hello World" شروع خواهیم کرد که یکی از ساده‌ترین برنامه‌های Node.js است.</p>
                                    <p>سپس درباره ساخت یک برنامه واقعی صحبت خواهیم کرد که قصد ساخت آن را داریم. این موضوع به‌صورت قدم‌به‌قدم پیش خواهد رفت و این نیاز وجود دارد که قسمت‌های مختلف پیاده‌سازی برنامه را تشریح کرد.</p>
                                    <p>همان‌طور که بیان شد، در مسیر این آموزش با بعضی از مباحث پیشرفته جاوااسکریپت آشنا خواهید شد که از آن‌ها استفاده خواهید کرد و این حس را خواهد داد که چرا باید بجای تکنیک‌هایی در دیگر زبان‌ها از این تکنیک‌ها استفاده کنیم.</p>
                                    <br>
                                    <h3 class="head--color">سخن مترجم</h3>
                                    <p>به جرأت باید گفت یکی از انقلابی‌ترین گام‌های رو‌به‌جلو در حوزه وب ظهور Node.js بوده که روز‌به‌روز بر محبوبیت این فناوری افزوده می‌شود. هدف از ترجمه این کتاب صرفاً تلاشی صادقانه و ناچیز برای پیشبرد دانش در حوزه وب فارسی بوده است، افزون بر این در ساختار ترجمه تمامی تلاش بر این بوده که ترجمه روان باشد و خواننده به‌راحتی بتواند مفاهیم را درک کند.</p>
                                    <p>باید در نظر داشت که فقط این نسخه از کتاب(ترجمه فارسی) به‌صورت رایگان و با کسب اجازه از نویسنده کتاب انتشار یافته است.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="bb-item" id="item4">
                        <div class="content">
                            <div class="scroller">
                                <h2>جاوااسکریپت و Node.js</h2>
                                <div class="page">
                                    <h3 class="head--color">جاوااسکریپت و شما</h3>
                                    <p>قبل از پرداختن به مباحث فنی، باید به رابطه شما و جاوااسکریپت اشاره کرد. در این فصل به شما کمک خواهیم کرد که میزان رابطه خود با جاوااسکریپت را برآورد کنید.</p>
                                    <p>اگر شما نیز همانند من دنیای وب را سال‌ها پیش با "HTML" شروع کرده‌اید مطمئناً با کلمه جذاب جاوااسکریپت آشنا هستید، اما احتمالاً جاوااسکریپت را صرفاً برای ایجاد تعامل بهتر کاربران با صفحات وب استفاده کرده‌اید.</p>
                                    <p>باید پرسید خواسته حقیقی شما برای ساخت "یک برنامه واقعی" چیست، شما می‌خواهید بدانید که چگونه می‌توان یک برنامه پیچیده پیاده‌سازی کرد، شما یاد خواهید گرفت که از ابتدا همچون زبان‌های PHP، Ruby، Java در Node.js برنامه‌نویسی کنید.</p>
                                    <p>با این اوصاف، همچنان نیاز دارید که یک چشمتان بر روی جاوااسکریپت باشد، مطمئناً با jQuery و مباحثی همچون Prototype آشنا هستید. باید دقت کرد که جاوااسکریپت واقعاً سرزمینی بزرگ و پیشرفته‌ای است و فقط به دستور window.open() ختم نمی‌شود.</p>
                                    <p>هرچند تا به اینجا به قسمت Front-End پرداخته شد، اما درنهایت با jQuery هم قادر بودیم موارد زیبایی را پیاده‌سازی کنیم ولی باید گفت فقط به‌عنوان یک استفاده‌کننده جاوااسکریپت نه به‌عنوان توسعه‌دهنده جاوااسکریپت(JavaScript Developer). حال Node.js آمده است، می‌خواهیم از جاوااسکریپت در سمت سرور استفاده کنیم. چقدر می‌تواند عالی باشد؟</p>
                                    <p>شما تصمیم گرفته‌اید جاوااسکریپت قدیمی را فراموش کنید(استفاده در مرورگر) و قسمت جدید آن را یاد بگیرید. اما صبر کنید، برنامه‌نویسی در Node.js فقط یک‌چیز است: چرا توسعه‌دهندگان Node.js این سبک را ابداع کرده‌اند و چرا ما نیاز داریم جاوااسکریپت را درک کنیم. واقعیت همین است.</p>
                                    <p>نکته جالب: ازآنجاکه جاوااسکریپت دو بار زنده شده است احتمالاً این سومی است ☻ (کمک DHTML در اواسط دهه 90، به وجود آمدن jQuery و حال Node در سمت سرور)، در مسیر نوشتن برنامه‌های Node.js حس نخواهید کرد که در حال استفاده از جاوااسکریپت هستید اما در حقیقت یاد خواهید گرفت که آن را توسعه دهید.</p>
                                    <p>در حال حاضر شما یک توسعه‌دهنده باتجربه هستید و نمی‌خواهید تکنیک جدیدی را یاد بگیرید که در مسیر غلط(Hacking) از آن استفاده کنید، می‌خواهید به‌صورت کامل از آن در مسیر صحیح استفاده کنید.</p>
                                    <p>مطمئناً مستندات عالی‌تری بیرون از این کتاب وجود دارد اما مستندات بعضی مواقع به‌تنهایی کافی نیست. هدف از تألیف این کتاب تنها فراهم شدن یک راهنمایی مناسب برای مبتدی‌ها است.</p>
                                    <br><br>
                                    <h3 class="head--color">اخطار</h3>
                                    <p>واقعاً افرادی هستند که جاوااسکریپت را خیلی عالی می‌داند، که من یکی از آن‌ها نیستم.</p>
                                    <p>من درنهایت به فردی خلاصه می‌شوم که فقط پاراگراف قبلی را توضیح داده‌ام اما مواردی را در مورد توسعه برنامه‌های تحت وب می‌دانم. لازم به ذکر است که در زمینه جاوااسکریپت و Node.js واقعاً یک تازه‌کار هستم و اخیراً جنبه‌های پیشرفته جاوااسکریپت را فراگرفته‌ام و یک فرد مجرب در این زمینه نیستم.</p>
                                    <p>به همین دلیل است که هیچ کتابی با عنوان "از مبتدی به متخصص" وجود ندارد. این کتاب بیشتر به "از مبتدی به مبتدی پیشرفته" خواهد پرداخت.</p>
                                    <p>اگر من با شکست مواجهه نشوم، این کتاب می‌تواند همان کتابی باشد که آرزو داشتم زمانی که Node.js را شروع کرده بودم آن را می‌داشتم.</p>
                                    <br><br>
                                    <h3 class="head--color">جاوااسکریپت در سمت سرور</h3>
                                    <p>اولین برداشت شما از جاوااسکریپت استفاده آن در مرورگر است اما این فقط یک قرارداد ساده می‌باشد.</p>
                                    <p>تعریف فوق اشاره می‌کند که شما چه کاری می‌توانید با زبان انجام دهید اما این تعریف درباره اینکه خود زبان چه کاری می‌تواند انجام دهد را مشخص نمی‌کند.</p>
                                    <p>Node.js حقیقتاً یک موضوع دیگری است: به شما این اجازه را خواهد داد که جاوااسکریپت را در Backend اجرا کنید بدون نیاز به مرورگر.</p>
                                    <p>بدین منظور باید در Backend تفسیر و اجرا صحیحی داشته باشیم. حال Node.js چگونه عمل می‌کند؟</p>
                                    <p>Node.js به‌وسیله موتور جاوااسکریپت V8 که توسط شرکت Google توسعه‌یافته است می‌تواند یک محیط در زمان اجرا(Runtime) برای جاوااسکریپت را ایجاد کند همانند مرورگر Google Chrome که از آن استفاده می‌کنید.</p>
                                    <p>به‌علاوه Node.js دارای ماژول‌های مفید زیادی است، بنابراین شما نیاز ندارید همه چیز را از اول بنویسید.</p>
                                    <p>درنهایت باید گفت Node.js واقعاً دو چیز است: یک محیط در زمان اجرا و یک کتابخانه.</p>
                                    <p>به‌منظور استفاده، نیاز به نصب و آماده‌سازی Node.js دارید. برای این منظور می‌توانید از مستندات رسمی‌Node.js استفاده کنید و درصورتی‌که به زبان انگلیسی تسلط ندارید می‌توانید به وبلاگ جامعه Node.js فارسی رجوع کنید که در زیر اشاره شده است:</p>
									<ul>
										<li><a href="https://nodejs.org/en/">وب سایت رسمی‌Node.js</a></li>
										<li><a href="http://nodejs.ir/">Node فارسی</a></li>
										<li><a href="http://nodejs.ir/blog/setting-up-node-and-development-environment">نصب و آماده‌سازی محیط توسعه Node.js</a></li>
									</ul>
									<br><br>
                                    <h3 class="head--color">برنامه "سلام دنیا"</h3>
									<p>خیلی خوب، بیاید اولین برنامه سنتی و قدیمی‌"سلام دنیا" را در Node.js بنویسیم.</p>
									<p>ویرایشگر موردعلاقه خودتان را باز کنید و یک سند با عنوان helloworld.js ایجاد کنید. می‌خواهیم به‌وسیله این برنامه یک رشته با عنوان سلام دنیا را نمایش دهیم. برای این منظور دستور زیر را بنویسید:</p>
									<table>
										<tr><td>console.log("Hello World");</td></tr>
									</table>
									<p>فایل را ذخیره کنید.</p>
									<p>ابتدا خط فرمان(ترمینال) سیستم‌عامل خود را درجایی که فایل ذخیره شده است باز کنید و سپس با دستور زیر به‌وسیله Node.js برنامه را اجرا کنید:</p>
									<table>
										<tr><td>node helloworld.js</td></tr>
									</table>
									<p>در خروجی خط فرمان باید Hello World نوشته شده باشد.</p>
									<p>این مثال خیلی جالب نیست، درسته؟ در فصل بعد به تشریح یک برنامه پیچیده‌تر خواهیم پرداخت.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="bb-item" id="item5">
                        <div class="content">
                            <div class="scroller">
                                <h2>یک برنامه کامل تحت وب به کمک Node.js</h2>
                                <div class="page">
									<h3 class="head--color">اهداف برنامه</h3>
									<p>قصد ساخت یک برنامه ساده اما کامل با ویژگی‌هاویژگی‌های زیر را داریم:</p>
									<ul>
										<li>کاربر باید قادر باشد از برنامه ما داخل مرورگر استفاده کند.</li>
										<li>کاربر باید در آدرس http://domain/start یک صفحه خوش‌آمد گویی مشاهده کند که شامل یک فرم آپلود تصویر است.</li>
										<li>کاربر به‌وسیله فرم قادر به آپلود تصویر باشد و این تصویر با آدرس http://domain/upload آپلود خواهد شد و نمایش داده می‌شود.</li>
									</ul>
									<p>ویژگی‌ها به‌اندازه کافی هستند، با جستجو کردن ممکن است در اینترنت به این هدف برسید اما آن چیزی نیست که ما می‌خواهیم اینجا انجام دهیم.</p>
									<p>از این گذشته، نمی‌خواهیم با نوشتن چند خط کد ساده به هدف اصلی برسیم و هرچند ممکن است کدهایی که می‌نویسیم زیبا و درست باشند اما قصد داریم به برنامه لایه‌های بیشتری اضافه کنیم که منجر خواهد شد حس کنید در حال ساخت یک برنامه پیچیده Node.js هستید.</p>
									<br><br>
                                    <h3 class="head--color">تشریح ساختار برنامه</h3>
									<p>بیاید ساختار برنامه را تشریح کنیم، بخش‌هایی که برای پیاده‌سازی برنامه نیاز داریم به تفکیک زیر شرح داده شده است:</p>
									<ul>
										<li>می‌خواهیم برنامه بر بستر وب و در مرورگر اجرا شود،‌ بنابراین به یک HTTP سرور نیاز داریم.</li>
										<li>برنامه ما ممکن است به درخواست‌هایی مختلفی پاسخ دهد که بستگی به آدرس‌هایی دارد که تقاضا می‌شود، بدین ترتیب به یک مسیریاب نیاز خواهیم داشت که بتواند کنترلر یک درخواست را بیابد.</li>
										<li>درخواست‌هایی که به سرور وارد می‌شوند نیاز به مسیریابی دارند و درنهایت باید مدیریت شوند، بنابراین باید برای درخواست‌ها کنترلر تعریف کنیم. (Request Handlers)</li>
										<li>مسیریاب باید برای مدیریت درخواست‌های POST یک راه‌حل داشته باشد چراکهچراکه نیاز داریم اطلاعات را از آن بگیریم. (Request Data Handling)</li>
										<li>فقط نمی‌خواهیم درخواست‌ها را مدیریت کنیم، همچنین باید پاسخ‌هایی را برای آن‌ها در نظر بگیریم، به عبارت دیگر نیاز داریم یک بخش نمایش(View) داشته باشیم که محتوا را بر بستر مرورگر نمایش دهد.</li>
										<li>در آخر، کاربر باید قادر باشد فایل موردنظر خود را آپلود کند که نیاز داریم فایل های آپلودی را مدیریت کنیم. (Upload Handling)</li>
									</ul>
									<p>چند لحظه فکر کنید که پیاده‌سازی این برنامه با PHP چگونه خواهد بود. مسلماً مثل رازی نیست که نیاز به تنظیم خاصی داشته باشد ممکن است فقط نیاز داشته باشیم که ماژول mod_php5 از آپاچی سرور را نصب کنیم.</p>
									<p>بسیار خوب، این برنامه با Node مقداری متفاوت‌تر خواهد بود چراکه فقط قصد پیاده‌سازی برنامه را نداریم در حقیقت می‌خواهیم یک HTTP سرور را به همراه برنامه پیاده‌سازی کنیم.</p>
									<p>شاید فکر کنید کار سختی باشد،‌ اما می‌بینید که در یک لحظه با Node آن را پیاده خواهیم کرد. قبول ندارید؟</p>
									<p>در فصل بعد، از ابتدا به پیاده‌سازی یک HTTP سرور خواهیم پرداخت.</p>
								</div>
                            </div>
                        </div>
                    </div>
                    <div class="bb-item" id="item6">
                        <div class="content">
                            <div class="scroller">
                                <h2>پیاده سازی برنامه - بخش ۱</h2>
                                <div class="page">
									<h3 class="head--color">ایجاد یک HTTP سرور</h3>
									<p>در نقطه‌ای قرار داریم که قرار است اولین برنامه واقعی در محیط Node را آغاز کنیم، از این تعجب نکنیم که قرار است چگونه برنامه را پیاده‌سازی کنیم همچنین سازمان‌دهی کدها نیز مهم است.</p>
									<p>باید همه‌ی کدها را داخل یک فایل بنویسیم؟ آموزش‌های موجود در سطح وب به شما آموزش می‌دهند که چطور یک HTTP سرور ساده در Node بنویسید که اکثر آن‌ها تمامی کدها را در یک فایل می‌نویسند. اگر بخواهیم برنامه‌ای خوانا، دسترس‌پذیر و زیباتر داشته باشیم چه باید کرد؟</p>
									<p>مشخصاً این مسئله ساده است، تنها کافی است تفسیر درستی از برنامه داشته باشیم و کدها را سازمان‌دهی کنیم به‌گونه‌ای که قسمت‌های مختلف برنامه را در ماژول‌های مختلف قرار دهیم.</p>
									<p>این سبک به ما کمک می‌کند که فایل اصلی(Main File) برنامه تمیز‌تر و خواناتر باشد نسبت به اینکه تمامی قطعات برنامه را داخل یک فایل قرار دهیم و به‌راحتی می‌توانیم ماژول‌های مختلف را در فایل اصلی فراخوانی کنیم.</p>
									<p>بنابراین ابتدا باید فایل اصلی برای برنامه را ایجاد کنیم و ماژول HTTP سرور را در آن فراخوانی کنیم.</p>
									<p>یکی از استانداردترین نام‌ها در دنیای برنامه‌نویسی عنوان index است که ما هم از این استاندارد برای فایل اصلی استفاده خواهیم کرد - Index.js</p>
									<p>برای آنکه HTTP سرور را بسازیم، آن را در ماژولی به نام server.js پیاده‌سازی می‌کنیم. در ریشه پروژه فایلی به نام server.js ایجاد کنید و کد زیر را در آن قرار دهید:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>http.createServer(function(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}).listen(8888);</td></tr>
									</table>
									<p>بسیار خوب، فقط کافی است برنامه را اجرا کنید. خط فرمان را در ریشه پروژه باز کنید و دستور زیر را وارد کنید:</p>
									<table>
										<tr><td>node server.js</td></tr>
									</table>
									<p>حال مرورگر را باز کنید و آدرس http://localhost:8888/ را وارد کنید. این آدرس باید یک صفحه وب را به شما نشان دهد که درون آن عبارت Hello World ذکر شده است.</p>
									<p>دقیقاً در یک‌لحظه HTTP سرور ساخته شد و این بسیار جالب است، در قسمت بعد به تشریح قطعه کد بالا خواهیم پرداخت و کدهای برنامه را سازمان‌دهی می‌کنیم.</p>
									<br><br>
                                    <h3 class="head--color">آنالیز HTTP سرور</h3>
									<p>بسیار خوب، در خط ابتدایی قطعه کد بالا ابتدا با require الزام کرده‌ایم که ماژول http فراخوانی شود و آن را در متغیر http قرار داده‌ایم که به ما کمک می‌کند به HTTP سرور دسترسی داشته باشیم.</p>
									<p>سپس یکی از توابع ماژول http را صدا زدیم: createServer - این تابع یک شیء را به‌عنوان خروجی برمی‌گرداند و دارای متدی با عنوان listen است که یک مقداری عددی می‌پذیرد که معادل شماره پورت HTTP سرور است و برنامه تا زمانی که در حال اجرا است به این پورت گوش می‌دهد و در صورت وجود هرگونه درخواست به آن پاسخ خواهد داد.</p>
									<p>حال کدهای داخل تابع http.createServer را نادیده بگیرید به شکل زیر:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td></td></tr>
										<tr><td>var server = http.createServer();</td></tr>
										<tr><td>server.listen(8888);</td></tr>
									</table>
									<p>اگر قطعه کد بالا را همانند روش قبل اجرا کنید فقط یک HTTP سرور ایجاد کرده‌ایم که به پورت 8888 گوش می‌دهد و دیگر هیچ عملکردی نخواهد داشت.</p>
									<p>نکته جالبی در قسمت پارامترهای تابع createServer وجود دارد، شاید انتظار داشتید که یک متغیر را به‌عنوان پارامتر عبور دهیم اما مشاهده می‌کنید که یک تابع را به‌عنوان پارامتر برای تابع createServer عبور داده‌ایم.</p>
									<p>این نوع تعریف تابع همانند createServer تنها مختص جاوااسکریپت است. توابع به‌عنوان پارامتر می‌توانند در توابع دیگر مورد استفاده قرار گیرند.</p>
									<br><br>
                                    <h3 class="head--color">آشنایی با توابع ناهم‌زمان</h3>
									<p>به عنوان مثال به کد زیر دقت کنید:</p>
									<table>
										<tr><td>function say(word) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log(word);</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function execute(someFunction, value) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;someFunction(value);</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>execute(say, "Hello");</td></tr>
									</table>
									<p>قطعه کد بالا را به‌دقت مطالعه کنید! در کد بالا در خط نهم تابع say را به‌عنوان اولین پارامتر از تابع excute عبور داده‌ایم که منجر به صدازدن تابع say در تابع execute خواهد شد.</p>
									<p>بنابراین، تابع say جایگزین متغیر محلی someFunction در تابع execute خواهد شد و execute می‌تواند someFunction را صدا بزند.</p>
									<p>همان‌طور که مشاهده کردید قادر هستیم یک تابع را با نام خودش به‌عنوان پارامتر از یک تابع دیگر عبور دهیم. حتی می‌توانیم یک تابع را به‌صورت درجا(in-place) استفاده کنیم. برای درک بهتر قطعه کد زیر را بررسی کنید:</p>
									<table>
										<tr><td>function execute(someFunction, value) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;someFunction(value);</td></tr>
										<tr><td>}</td></tr>
										<tr><td>server.listen(8888);</td></tr>
										<tr><td>execute(function(word){ console.log(word) }, "Hello");</td></tr>
									</table>
									<p>در این روش، حتی دیگر نیاز به گرفتن نام تابع نداریم و این نوع توابع را ناهم‌زمان می‌گوییم.</p>
									<p>به‌طورکلی، این اولین قسمت است که مایلم آن را جاوااسکریپت پیشرفته نام‌گذاری کنم. اما قدم‌به‌قدم بیشتر آشنا خواهید شد و فعلاً می‌توانیم بگوییم که یک تابع را به‌عنوان پارامتر عبور داده‌ایم زمانی که تابع دیگری را صدا بزنیم.</p>
									<br><br>
                                    <h3 class="head--color">چگونگی کار کردن HTTP سرور به کمک توابع ناهم‌زمان</h3>
									<p>با اطلاعاتی که کسب نموده‌ایم،‌ بگذارید به HTTP سرور خود بازگردیم:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td></td></tr>
										<tr><td>http.createServer(function(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}).listen(8888);</td></tr>
									</table>
									<p>در حال حاضر برای ما واضح است که کد بالا چه کاری انجام می‌دهد: استفاده از تابع createServer به‌عنوان یک نوع تابع ناهم‌زمان.</p>
									<p>می‌توانیم شکل بهتری را در نظر بگیریم:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td></td></tr>
										<tr><td>function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>http.createServer(onRequest).listen(8888);</td></tr>
									</table>
									<p>ممکن است بپرسید چرا این کار را انجام داده‌ایم.</p>
									<br><br>
                                    <h3 class="head--color">برنامه‌نویسی رویداد محور ناهم‌زمان بر پایه Callbackها</h3>
									<p>برای درک اینکه چرا Node.js از این روش استفاده می‌کند بهتر است نحوه اجرا شدن کدها توسط Node.js را دریابیم. روش Node.js یک روش انحصاری نیست اما زیربنای مدل‌های آن با محیط‌های در زمان اجرا(Runtime Environments) مثل Python, Ruby, PHP یا Java تفاوت دارد.</p>
									<p>به مثال زیر دقت کنید:</p>
									<table>
										<tr><td>var result = database.query("SELECT * FROM hugetable");</td></tr>
										<tr><td>console.log("Hello World");</td></tr>
									</table>
									<p>لطفاً به مسئله اتصال به پایگاه داده فکر نکنید به فرض از قبل به پایگاه داده متصل بوده‌‌ایم. در خط اول یک کوئری(query) وجود دارد که سطرهای زیادی از جدول hugetable را فراخوانی می‌کند. در خط دوم عبارت Hello World را چاپ خواهد شد.</p>
									<p>فرض کنید حجم کوئری بالا و سرعت بسیار پایین باشد، به‌قدری که به‌سختی می‌تواند چند سطر را بخواند.</p>
									<p>در کدی که به روش فوق نوشته شده است ابتدا مفسر جاوااسکریپت نتیجه کوئری را کامل می‌خواند و سپس خط دوم می‌تواند اجرا شود.</p>
									<p>اگر واقعاً کد فوق وجود داشته باشد، مطمئناً PHP قادر به اجرای آن است: اجرای کوئری و نمایش عبارت Hello World. اگر این کد به‌عنوان اسکریپت بخشی از یک صفحه وب باشد قاعدتاً کاربر چندین ثانیه منتظر خواهد ماند تا صفحه کامل بارگذاری شود.</p>
									<p>هرچند این مدل اجرا در PHP یک مشکل عمومی حساب نمی‌شود و PHP می‌توانید این مثال را پیاده کند اما ممکن است تعدادی از درخواست‌ها ناکامل بمانند و بعضی از کاربران به نتیجه موردنظر نرسند.</p>
									<p>مدل اجرا در Node.js متفاوت‌تر است – فقط یک فرآیند در Node.js وجود دارد. اگر یک کوئری سنگین در یک فرآیند وجود داشته باشد، تا زمانی که کوئری به پایان نرسد دیگر فرآیند‌ها اجرا نخواهند شد و به حالت توقف در خواهند آمد.</p>
									<p>برای حل این مشکل، راهکار جاوااسکریپت و سپس Node.js برنامه‌نویسی رویداد محور(Event-Driven) به‌صورت ناهم‌زمان(Asynchronous) است با استفاده از حلقه رویداد(Event Loop).</p>
									<p>برای درک این مفهوم به بررسی کد زیر خواهیم پرداخت:</p>
									<table>
										<tr><td>database.query("SELECT * FROM hugetable", function(rows) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var result = rows;</td></tr>
										<tr><td>});</td></tr>
										<tr><td>console.log("Hello World");</td></tr>
									</table>
									<p>در اینجا، بجای آنکه در انتظار باشیم که database.query() نتیجه نهایی را به‌صورت مستقیم برای ما بازگرداند، ما آن را در قالب پارامتر دوم عبور می‌دهیم. حال یک تابع ناهم‌زمان داریم.</p>
									<p>در حالت قبلی، کد نوشته شده به شکل هم‌زمان بود: ابتدا کوئری موردنظر اجرا می‌شد و فقط پس از اتمام کامل آن، قادر به نوشتن در خط فرمان بودیم.</p>
									<p>حال با روشی که بیان شد Node.js قادر است که کوئری‌های دیتابیس را به‌صورت ناهم‌زمان مدیریت کند و database.query() را به شکل ناهم‌زمان ارائه کند که در این حالت Node.js ابتدا درخواست اجرا را ارسال می‌کند اما بجای آنکه منتظر باشد تا کوئری کامل به پایان برسد یادآوری می‌کند "در هر زمان که کوئری به پایان رسید نتیجه آن را ارسال کن و باید پس‌ازآن تابع ناهم‌زمان را اجرا کند که قبلاً database.query() را از آن عبور داده‌ایم." سپس، بلافاصله console.log() پس‌ازآن اجرا خواهد شد و وارد حلقه رویداد می‌شود. Node.js به‌طور مداوم این چرخه را دنبال خواهد کرد و درنهایت هیچ فرآیندی باقی نخواهند ماند.</p>
									<p>موضوع فوق به ما توضیح خواهد داد که چرا HTTP سرور نیاز به یک تابع دارد برای پاسخ دادن به درخواست‌های ورودی – ممکن است Node.js شروع به کار کند و سپس متوقف شود، این حالت ادامه دارد تا زمانی که درخواست بعدی وارد شود که مسلماً این حالت کارآمد نیست. اگر یک کاربر دومی برای سرور، درخواست ارسال کند و در آن زمان سرور مشغول ارائه خدمت به درخواست اول باشد، درخواست دوم باید منتظر باشد تا درخواست اول به پایان برسد – به‌محض اینکه درخواست به تعداد انگشتان دست برسد HTTP سرور پاسخگوی نیاز شما در همه حالت نخواهد بود.</p>
									<p>نکته بسیار مهمی وجود دارد که در مدل اجرایی ناهم‌زمانی، تک فرآیندی و رویداد محور یک عملکرد مقیاس‌پذیر خاص وجود ندارد. توانستیم یکی از مدل‌های اجرایی در Node.js را بررسی کنیم و باید گفت محدودیت‌های خاص خود را دارد که می‌توان به تک فرآیندی بودن آن اشاره کرد و این قابلیت فقط یک هسته CPU را در برمی‌گیرد. این مدل کاملاً نزدیک به برنامه است و باوجود شیوه بسیار ساده‌ای که در خود دارد به‌راحتی می‌تواند با شرایط هم‌زمانی مقابله کند.</p>
									<p>ممکن است بخواهید تجربه بهتری نسبت به Node.js کسب کنید که می‌توانید مقاله بسیار عالی Felix Geisendoerfer’s را در این رابطه مطالعه کنید - <a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding Node.js</a></p>
									<p>اگر مایل باشید با مفهوم فوق بیشتر آشنا شویم. آیا می‌توانیم کد برنامه را طوری پیاده‌سازی کنیم که حتی بعد از ایجاد سرور به کار خود ادامه دهد حتی اگر هیچ درخواست HTTP وجود نداشته باشد و تابع Callback هم صدا نزده شده باشد؟ اجازه دهید امتحان کنیم:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td></td></tr>
										<tr><td>function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request received.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td></td></tr>
										<tr><td>console.log("Server has started.");</td></tr>
									</table>
									<p>در کد فوق با استفاده از دستور console.log یک عبارت هرزمان که یک درخواست HTTP وجود داشته باشد چاپ می‌شود و درست بعد از شروع به کار HTTP سرور عبارت دیگری چاپ می‌شود.</p>
									<p>زمانی که برنامه را اجرا کنیم(node server.js)، بلافاصله عبارت "Server has started." در خط فرمان چاپ خواهد شد علاوه بر این هرگاه درخواستی(به‌وسیله باز شدن آدرس http://localhost:8888/ ) به سمت سرور ارسال شود عبارت "Request received." در خط فرمان چاپ می‌شود.</p>
									<p>تا به اینجا به‌صورت عملی جاوااسکریپتِ رویداد محور ناهم‌زمان به‌وسیله Callbackها را بررسی کردیم.</p>
									<p>(نکته: احتمالاً هنگامی‌که درخواستی به سمت سرور ارسال شود در خط فرمان دو بار پیام "Request received." را مشاهده کنید به دلیل اینکه بیشتر مرورگر‌ها سعی دارند که با ارسال هر درخواست اقدام به بارگذاری Favicon در آدرس http://localhost:8888/favicon.ico کنند.)</p>
									<br><br>
                                    <h3 class="head--color">مسیریابی (1): چگونگی کنترل درخواست‌ها در سرور</h3>
									<p>بسیار خوب، اجازه دهید به‌صورت سریع باقی کدهای سرور را آنالیز کنیم - تابع onRequest()</p>
									<p>زمانی که تابع Callback یعنی onRequest صدا زده می‌شود، از خود دو پارامتر request و response را عبور می‌دهد.</p>
									<p>request و response هردو از نوع شیء هستند و می‌توانیم از متدهای آن‌ها برای کنترل کردن درخواست‌های HTTP که رخ داده‌اند استفاده کنیم و همچنین به درخواست‌ها پاسخ دهیم.</p>
									<p>کد ما نیز همانند عبارت فوق عمل می‌کند: هر زمان که یک درخواست دریافت شود به‌وسیله تابع response.writeHead() وضعیت 200 و content-type را برای هدر  HTTP ارسال می‌کند و سپس تابع response.write() عبارت "Hello World" را برای بدنه  HTTP ارسال می‌کند و بر روی صفحه‌نمایش داده می‌دهد. در انتها، تابع response.end() را فراخوانی می‌کنیم که پاسخ دادن به درخواست را پایان می‌دهد.</p>
									<p>تا انتهای برنامه شیء request اهمیت خاصی برای برنامه ندارد و به جزئیات آن نمی‌پردازیم.</p>
									<br><br>
                                    <h3 class="head--color">سازمان‌دهی کدها به کمک ماژول‌ها</h3>
									<p>در این مرحله به بررسی اینکه چگونه می‌توان برنامه را بهتر سازمان‌دهی کنیم خواهیم پرداخت. در داخل فایل server.js تکه کد بسیار ساده‌ای داریم که مرتبط به HTTP سرور است و در فصول قبل ذکر شد که برنامه دارای یک فایل اصلی است که با عنوان index.js از آن استفاده می‌کنیم که به‌عنوان نقطه شروع برنامه تلقی می‌شود و کمک می‌کند کدها را بهتر سازمان‌دهی کنیم.</p>
									<p>اجازه دهید در مورد چگونگی استفاده از server.js به‌عنوان یک ماژول واقعی در Node.js صحبت کنیم که آیا واقعاً می‌توان از آن در فایل اصلی برنامه(index.js) استفاده کرد؟</p>
									<p>همان‌طور که می‌دانید در کدها از یک ماژول به شکل زیر استفاده کردیم:</p>
									<table>
										<tr><td>var foo = require("http");</td></tr>
										<tr><td></td></tr>
										<tr><td>...</td></tr>
										<tr><td></td></tr>
										<tr><td>foo.createServer(...);</td></tr>
									</table>
									<p>اگر برایتان سؤال شده است که ماژول http از کجا می‌آید؟ باید گفت که Node.js در هسته خود ماژول‌هایی را به‌صورت پیش‌فرض دارد و به برنامه‌نویس کمک می‌کند که چرخه برنامه‌نویسی را از ابتدا شروع نکند و با افزودن به کدها می‌توانیم از ماژول‌ها استفاده کنیم به شکلی که آن‌ها را در یک متغیر محلی فراخوانی کنیم.</p>
									<p>این باعث می‌شود که متغیرهای محلی به شکل یک شیء استفاده شوند و به‌تمامی متدهای عمومی‌http دسترسی داشته باشند.</p>
									<p>می‌توان برای سهولت برنامه‌نویسی از نام ماژول‌ها برای نام‌گذاری متغیرها استفاده کرد اما درهرحال در انتخاب نام متغیر آزاد هستیم، مانند قطعه کد زیر:</p>
									<table>
										<tr><td>var foo = require("http");</td></tr>
										<tr><td></td></tr>
										<tr><td>...</td></tr>
										<tr><td></td></tr>
										<tr><td>foo.createServer(...);</td></tr>
									</table>
									<p>بسیار خوب، با نحوه استفاده از ماژول‌های داخلی Node.js آشنا شدید. چگونه می‌توانیم ماژول‌های خود را بسازیم و از آن‌ها استفاده کنیم؟</p>
									<p>مشخصاً برنامه ما نباید زیاد تغییر داشته باشد، تبدیل کدهای برنامه به ماژول به این نیاز دارد که کد را به‌گونه‌ای بازنویسی کنیم که بتوانیم از قابلیت‌ها آن خروجی بگیریم و درنهایت ماژول را فراخوانی کنیم.</p>
									<p>در حال حاضر، به شکل ساده‌ای نیاز داریم که از قابلیت‌های HTTP سرور استفاده کنیم: اسکریپت‌های ماژول برنامه را الزام کنند که سرور باید شروع به کار کند.</p>
									<p>برای این ممکن، قطعه کد زیر را در تابعی با عنوان start قرار می‌دهیم و این تابع را به بیرون صادر می‌کنیم:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request received.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>حال می‌توانیم فایل اصلی برنامه را با نام index.js ایجاد کنیم و در آن از HTTP سرور استفاده کنیم به‌وسیله کدهایی که هنوز در فایل server.js قرار دارد.</p>
									<p>فایلی را با عنوان index.js در کنار فایل server.js ایجاد کنید و کد زیر را در آن قرار دهید:</p>
									<table>
										<tr><td>var server = require("./server");</td></tr>
										<tr><td></td></tr>
										<tr><td>server.start(...);</td></tr>
									</table>
									<p>همان‌طور که مشاهده می‌کنید، به‌وسیله فراخوانی فایل server.js و ارجاع دادن ماژول به یک متغیر با نام server از ماژول server همانند یک ماژول داخلی استفاده کرده‌ایم و درنهایت می‌توانیم از توابع آن استفاده کنیم.</p>
									<p>همین بود، حال به کمک کد زیر می‌توانیم برنامه را با فایل اصلی آن شروع کنیم:</p>
									<table>
										<tr><td>node index.js</td></tr>
									</table>
									<p>بسیار عالی، به کمک مفهوم فوق می‌توانیم برنامه را به ماژول‌های مختلف تقسیم‌بندی و استفاده کنیم.</p>
									<p>تا به اینجا فقط اولین قسمت از برنامه را نوشته‌ایم که می‌تواند درخواست‌های HTTP را دریافت کند. بر روی درخواست‌ها باید کارهای دیگری نیز صورت گیرد و این بستگی به آدرس‌هایی دارد که از طرف مرورگر درخواست می‌شوند که باید واکنش‌های مختلفی را برای آن‌ها در نظر بگیریم.</p>
									<p>برای همچنین برنامه بسیار ساده‌ای می‌توانیم نیازهایمان را با تابع کال‌بک onRequest مرتفع کنیم اما ازآنجایی‌که گفت شد، می‌خواهیم برنامه مقداری لایه‌های بیشتر در خود داشته باشد و این فرآیند جذاب‌تر شود.</p>
									<p>برای آنکه برنامه بتواند به درخواست‌های متنوع HTTP پاسخ دهد باید یک مسیریاب در برنامه وجود داشته باشید، بنابراین باید یک ماژول با عنوان router ایجاد شود.</p>
									<br><br>
                                    <h3 class="head--color">مسیریابی (2): چرا باید درخواست‌ها را مسیریابی کنیم؟</h3>
									<p>برنامه باید قادر به تغذیه کردن درخواست‌ها باشد، ممکن است درخواست‌های POST و GET وارد مسیریاب شوند و در این مرحله مسیریاب باید تصمیم بگیرد کدام چه کدی را اجرا کند.(اجرا کردن کد، قسمت سوم برنامه را تشکیل می‌دهد: پس از دریافت درخواست، مسیریاب کد درست را برای آن برمی‌گرداند و اجرا می‌کند.)</p>
									<p>بنابراین، نیاز داریم تا پارامترهای موجود در URL را که از طریق POST/GET ارسال می‌شوند را استخراج و استفاده کنیم. می‌توان در نظر گرفت که بخشی از روتر باشد یا سرور(ماژول جداگانه) اما در حال حاضر اجازه دهید که آن را بخشی از HTTP سرور استدلال کنیم.</p>
									<p>تمامی اطلاعات موردنیاز را از طریق شیء request که به‌عنوان اولین پارامتر تابع کال‌بک onRequest عبور داده شده است بدست می‌آوریم. برای تجزیه و تفسیر بهتر request به تعدادی ماژول Node.js نیاز داریم که عبارت‌اند از: url و querystring</p>
									<p>ماژول url این امکان را می‌دهد که قسمت‌های مختلف یک URL را استخراج کنیم و به‌وسیله ماژول querystring می‌توانیم از پارامترهای آدرس استفاده کنیم.</p>
									<p>به مثال زیر توجه کنید:</p>
									<table>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url.parse(string).query</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url.parse(string).pathname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;------&nbsp;&nbsp;----------------------------</td></tr>
										<tr><td>http://localhost:8888/start?foo=bar&hello=world</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;querystring(string)["foo"]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;querystringtring(string)["hello"]</td></tr>
									</table>
									<p>البته می‌توانیم با استفاده از querystring بدنه یک درخواست POST را برای پارامترها تجزیه کنیم. در فصل‌های بعد با این موضوع بیشتر آشنا خواهید شد.</p>
									<p>اجازه دهید با اضافه کردن کد زیر به تابع onRequest() متوجه شویم که کاربر چه آدرسی را در مرورگر وارد کرده است:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>var url = require("url");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pathname = url.parse(request.url).pathname;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request for " + pathname + " received.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>بسیار خوب. در این زمان برنامه می‌تواند درخواست‌های مبتنی بر URL را تشخیص دهید و این به ما اجازه می‌دهد که کنترلرها را براین اساس طراحی کنیم.</p>
									<p>برنامه ما باید قادر باشد آدرس‌های /start و /upload را کنترل کند، در ادامه به این موضوع می‌پردازیم.</p>
									<p>زمان واقعی برای پیاده‌سازی مسیریاب فرا رسیده است، یک فایل با عنوان router.js ایجاد کنید و سپس کد زیر را در آن قرار دهید:</p>
									<table>
										<tr><td>function route(pathname) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("About to route a request for " + pathname);</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.route = route;</td></tr>
									</table>
									<p>البته کد فوق هیچ عملکرد خاصی ندارد اما در حال حاضر کافی است. ابتدا اجازه دهید قبل از اعمال کدهای اصلی بررسی کنیم که چگونه می‌توانیم مسیریاب را به سرور متصل کنیم.</p>
									<p>HTTP سرور نیاز دارد بداند که چگونه می‌تواند از مسیریاب(Router) استفاده کند. به دلیل اینکه مسیرهای سختی را در زبان‌های دیگر آموخته و تجربه کرده‌ایم شاید حس کنید باید ارتباط تنگاتنگی مابین مسیریاب و سرور ایجاد شود، اما قصد داریم با تزریق این وابستگی ارتباط زوج سرور و مسیریاب را آزادتر کنیم.</p>
									<p>ابتدا تابع start() سرور را توسعه می‌دهیم که به ما این اجازه را می‌دهد روتر درخواست‌ها را مسیریابی کند:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>var url = require("url");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(route) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pathname = url.parse(request.url).pathname;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request for " + pathname + " received.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;route(pathname);</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>و همچنین باید فایل index.js را توسعه داد که براین اساس تابع route را به سرور تزریق می‌کنیم:</p>
									<table>
										<tr><td>var server = require("./server");</td></tr>
										<tr><td>var router = require("./router");</td></tr>
										<tr><td></td></tr>
										<tr><td>server.start(router.route);</td></tr>
									</table>
									<p>مجدداً، یک تابع را به‌عنوان پارامتر عبور داده‌ایم که در فصول پیش این مفهوم را بررسی کردیم.</p>
									<p>اگر برنامه را اجرا کنیم(node index.js، برای همیشه) و درخواستی را برای آن ارسال کنیم، می‌توانیم بگوییم که برنامه از مسیریاب(Router) استفاده کرده و درخواست را از خود عبور داده است، خروجی خط فرمان شما باید مشابه زیر باشد:</p>
									<table>
										<tr><td>$ node index.js</td></tr>
										<tr><td>Request for /foo received.</td></tr>
										<tr><td>About to route a request for /foo</td></tr>
									</table>
									<p>(در اینجا درخواست /favicon.ico از خروجی حذف شده است.)</p>
								</div>
                            </div>
                        </div>
                    </div>
                    <div class="bb-item" id="item7">
                        <div class="content">
                            <div class="scroller">
                                <h2>پیاده سازی برنامه - بخش ۲</h2>
                                <div class="page">
									<h3 class="head--color">عمل کنید بجای نام بردن</h3>
									<p>ممکن است دوباره بخواهیم در مورد برنامه‌نویسی تابعی صحبت کنیم.</p>
									<p>عبور دادن توابع تنها یک مبحث فنی نیست، با توجه به مبحث طراحی نرم‌افزار ممکن است فلسفی باشد. چند لحظه فکر کنیم: درون فایل index ما توانستیم شیء router را از سرور عبور دهیم و همچنین سرور توانست تابع route را از این شیء فراخوانی کند.</p>
									<p>ازاین‌رو توانسته‌ایم یک شیء را عبور دهیم و ممکن است سرور از این شیء استفاده کند و کاری بر روی آن انجام دهد. "سلام مسیریاب، ممکن است این آدرس رو برای من پیدا کنی؟"</p>
									<p>متوجه هستیم که سرور نیاز به شیء ندارد بلکه فقط نیاز دارد چیزی را بگیرد و کاری بر روی آن انجام دهد، ما نیز به شیء نیاز نداریم بلکه نیاز به عمل داریم. نیاز به نام بردن نداریم، نیاز به فعل داریم.</p>
									<p>درک این مسئله نیاز به تغییر ذهنیت دارد تا جایی که در هسته این ایده باید پرسیده شود چرا من باید برنامه‌نویسی تابعی را بفهمم.</p>
									<p>و من این مسئله را زمانی متوجه شدم که مقاله <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Execution in the Kingdom of Nouns</a> را مطالعه کردم. برای درک بیشتر حتماً مقاله فوق را مطالعه کنید و یکی از بهترین مقالات مرتبط با توسعه نرم‌افزار است که مطالعه آن همیشه لذت‌بخش است.</p>
									<br><br>
                                    <h3 class="head--color">مسیریابی (3): مسیریابی درخواست‌ها برای یافتن کنترلر حقیقی</h3>
									<p>برگردیم به برنامه، تا جایی که در نظر گرفتیم، HTTP سرور و مسیریاب بهترین دوست هستند و با هم مکالمه دارند.</p>
									<p>البته این مفهوم "مسیریابی" کافی نیست، می‌خواهیم آدرس‌های مختلفی به شکل‌های مختلف را مدیریت کنیم. اینجا ممکن است بخواهیم برای درخواست‌های /start و /upload یک "منطق تجاری" را در نظر بگیریم.</p>
									<p>در حال حاضر مسیریابی در روتر بی‌معنی است، درواقع روتر کار خاصی بر روی درخواست‌ها انجام نمی‌دهد چراکه برای یک برنامه پیچیده عملکرد کافی را ندارد.</p>
									<p>می‌خواهیم هنگامی‌که یک درخواست به سمت کنترلر خود هدایت‌شده است، توابعی را صدا بزنیم.</p>
									<p>برای کنترلر درخواست‌ها قصد داریم ماژول جدیدی را ایجاد کنیم. فایلی با عنوان requestHandlers.js ایجاد می‌کنیم و برای درخواست‌های start و upload توابع را تعریف می‌کنم و درنهایت به‌صورت زیر آن‌ها را export می‌کنیم:</p>
									<table>
									<tr><td>function start() {</td></tr>
									<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
									<tr><td>}</td></tr>
									<tr><td></td></tr>
									<tr><td>function upload() {</td></tr>
									<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
									<tr><td>}</td></tr>
									<tr><td></td></tr>
									<tr><td>exports.start = start;</td></tr>
									<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>کد فوق این امکان را به ما می‌دهد که واپایشگرها را به روتر متصل کنیم و بتوانیم درخواست‌ها را به سمت کنترلر‌ها هدایت کنیم.</p>
									<p>در این مرحله نیاز به تصمیم‌گیری داریم: آیا برای استفاده از کنترلر‌ها در روتر کد مناسبی نوشته شده است یا می‌خواهیم مقدار بیشتری وابستگی تزریق کنیم؟ اگرچه تزریق وابستگی مشابه الگوهای دیگر است اما در این موضوع شرایط متفاوت است و با تزریق وابستگی‌ها ارتباط زوج روتر و کنترلر‌ها آزادانه‌تر خواهد بود و می‌توان از روتر استفاده مجدد کرد.</p>
									<p>مفهوم فوق اشاره می‌کند، کنترلر‌ها را از سرور به مسیریاب عبور دهیم که بسیار غلط است به همین دلیل باید کنترلرها را از فایل اصلی(index.js) عبور دهیم و سپس از آن به روتر انتقال دهیم.</p>
									<p>چطور آن‌ها را عبور دهیم؟ در حال حاضر در برنامه دو کنترلر وجود داد این مقدار ممکن است افزایش یا تغییر یابد و مطمئناً قصد نداریم کار بیهوده‌ای برای طراحی مسیریاب انجام دهیم یعنی هرگاه یک درخواست جدید داشته باشیم آن را به شکل if request==x مقایسه کنیم و سپس کنترلر را از روتر صدا بزنیم، این روش اصلاً درست و استاندارد نخواهد بود.</p>
									<p>تعدادِ متغیری از درخواست‌ها(آدرس‌های URL) وجود دارد که به شکل رشته(string) هستند. بسیار خوب ظاهراً آرایه‌های انجمنی  برای این مقصود مفید باشند.</p>
									<p>یافته‌ها در این زمینه ناامیدکننده هستند، آیا جاوااسکریپت می‌تواند آرایه‌های انجمنی را پیاده‌سازی کند یا نه؟ می‌دانیم که شیء ما واقعاً نیاز به استفاده از یک آرایه انجمنی دارد. </p>
									<p>برای این موضوع می‌توانیم به نکته‌ای از مقاله سایت MSDN Microsoft بپردازیم:</p>
									<p>زمانی که در C++ و C# در خصوص شیءها صحبت می‌کنیم درواقع به پیاده‌سازی کلاس‌ها(Classes) و ساختمان‌های داده(Structs) اشاره می‌کنیم. شیءها تفاوتهایی در ویژگی‌ها و متدهایشان دارند که بستگی به قالبی دارد که به ارث برده‌اند. مسئله این است که مبحث شیء‌ها در جاوااسکریپت مشابه C++ و C# نیست درواقع شیء‌ها در جاوااسکریپت فقط مجموعه‌ای از نام/مقدار هستند که به یکدیگر جفت شده‌اند. شیء‌ها را در جاوااسکریپت باید به شکل یک فرهنگ لغت نگاه کرد که مجموعه‌ای از کلید رشته‌ها در آن قرار دارد.</p>
									<p>اگر جاوااسکریپت فقط مجموعه‌ای از نام/مقدارهای جفت شده باشند، چطور می‌تواند متدهایی هم داشته باشد؟ خوب، مقادیر می‌توانند رشته، عدد و ... باشند و حتی یک تابع(function).</p>
									<p>در حال حاضر به نوشتن برنامه برمی‌گردیم. می‌خواهیم مجموعه‌ای از کنترلر‌ها را به‌عنوان یک شیء عبور دهیم و بر این اساس به یک زوج آزاد برسیم. درواقع شیء را به داخل route() تزریق کنیم.</p>
									<p>بگذارید شیءها را در کنار یکدیگر در فایل index.js را قرار دهیم:</p>
									<table>
										<tr><td>var server = require("./server");</td></tr>
										<tr><td>var router = require("./router");</td></tr>
										<tr><td>var requestHandlers = require("./requestHandlers");</td></tr>
										<tr><td></td></tr>
										<tr><td>var handle = {}</td></tr>
										<tr><td>handle["/"] = requestHandlers.start;</td></tr>
										<tr><td>handle["/start"] = requestHandlers.start;</td></tr>
										<tr><td>handle["/upload"] = requestHandlers.upload;</td></tr>
										<tr><td></td></tr>
										<tr><td>server.start(router.route, handle);</td></tr>
									</table>
									<p>بااینکه کنترلر بیشتر از یک "چیز"(مجموعه از درخواست‌ها) است، پیشنهاد می‌کنم اسم آن را مثل یک فعل در نظر بگیریم به این دلیل که نتیجه این نام‌گذاری در روتر بیان روانی را به دنبال خواهد داشت که به‌زودی خواهیم دید.</p>
									<p>تا اینجا که مشاهده کردید به‌راحتی می‌شود آدرس‌های مختلفی را به کنترلر موردنظر هدایت کرد: به‌وسیله اضافه کردن یک کلید/مقدار که با "/" به یکدیگر جفت شده‌اند، requestHandlers.start را می‌توانیم زیباتر و واضح‌تر بیان کنیم چراکه نه‌تنها درخواست‌های /start بلکه درخواست‌های / را می‌توانند به کنترلر start هدایت شوند.</p>
									<p>بعد از تعریف شیء آن را به‌عنوان پارامتر اضافی به داخل سرور عبور می‌دهیم. اجازه دهید تغییراتی در ماژول server.js ایجاد کنیم:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>var url = require("url");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(route, handle) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pathname = url.parse(request.url).pathname;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request for " + pathname + " received.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;route(handle, pathname);</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello World");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>یک پارامتر با عنوان handle به تابع start() اضافه کرده‌ایم و سپس شیء handle را به‌عنوان اولین پارامتر به داخل تابع کال‌بک route() عبور داده‌ایم.</p>
									<p>بر این اساس تابع route() درون فایل router.js نیز باید تغییراتی داشته باشد:</p>
									<table>
										<tr><td>function route(handle, pathname) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("About to route a request for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof handle[pathname] === 'function') {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle[pathname]();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;} else {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("No request handler found for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.route = route;</td></tr>
									</table>
									<p>چه کاری اینجا انجام داده‌ایم؟ ما بررسی می‌کنیم که اگر یک کنترلر مطابق با درخواست کاربر وجود دارد و همچنین اگر آن کنترلر نیز وجود دارد، تابع مرتبط با آن را صدا می‌زنیم. بنابراین می‌توانیم به توابع کنترلر شیء(Object) دسترسی داشته باشیم درست مانند اینکه به یک المنت از یک آرایه انجمنی دسترسی داشته باشیم، حال برای handle[pathname](); تعریف روان‌تری داریم که در قبل به آن اشاره شد:‌ " لطفاً، به این آدرس رسیدگی کن".</p>
									<p>بسیار خوب، همه آن چیزی که نیاز داریم متصل کردن سرور، روتر و کنترلر به یکدیگر است! هنگامی‌که برنامه اجرا شود و یک درخواست http://localhost:8888/start از مرورگر ارسال کنیم درواقع می‌توانیم اطمینان حاصل کنیم که کنترلر موردنظر فراخوانی شده است:</p>
									<table>
										<tr><td>Server has started.</td></tr>
										<tr><td>Request for /start received.</td></tr>
										<tr><td>About to route a request for /start</td></tr>
										<tr><td>Request handler 'start' was called.</td></tr>
									</table>
									<p>و اگر آدرس /http://localhost:8888 را در مرورگر باز کنیم به ما ثابت می‌کند که کنترلر این درخواست به‌درستی فراخوانی شده است:</p>
									<table>
										<tr><td>Server has started.</td></tr>
										<tr><td>Request for / received.</td></tr>
										<tr><td>About to route a request for /</td></tr>
										<tr><td>Request handler 'start' was called.</td></tr>
									</table>
									<br><br>
                                    <h3 class="head--color">مسیریابی (4): پاسخ دادن به درخواست‌ها</h3>
									<p>بسیار عالی، حال درواقع اگر تنها کنترلر بتواند چیزی به مرورگر برگرداند حتی بهتر خواهد شد.</p>
									<p>به یاد داشته باشید، هنگامی‌که یک صفحه را درخواست می‌کنیم عبارت "Hello World" نمایش داده می‌شود که دلیل آن تابع onRequest در فایل server.js است.</p>
									<p>"رسیدگی به درخواست‌ها" به معنی "پاسخ دادن به درخواست‌ها" است بدین منظور ما نیاز داریم که ایجاب کنیم کنترلر با مرورگر گفتگو کند درست مثل وظیفه‌ای که تابع onRequest انجام می‌دهد.</p>
									<p>روش ساده‌ای که به‌عنوان توسعه‌دهنده با پیشینه PHP و Ruby ممکن است بخواهیم آن را دنبال کنیم: کنترلر محتوایی که کاربر می‌خواهد نمایش داده شود را به داخل تابع onRequest ارسال کند و به کاربر ارائه دهد.</p>
									<p>ابتدا اجازه دهید این روش را پیاده‌سازی کنیم و بعد متوجه خواهید شد که این ایده مناسب نیست.</p>
									<p>با قسمت کنترلر شروع می‌کنم و طوری کد را بازنویسی می‌کنم که عبارت موردنظر در مرورگر نمایش داده شود. نیاز داریم که در فایل requestHandlers.js تغییراتی ایجاد کنیم:</p>
									<table>
										<tr><td>function start() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;return "Hello Start";</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;return "Hello Upload";</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>به‌علاوه روتر باید آن چیزی که از کنترلر درخواست شده را به سرور بازگرداند، ازاین‌رو router.js را به شکل زیر ویرایش می‌کنیم:</p>
									<table>
										<tr><td>function route(handle, pathname) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("About to route a request for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof handle[pathname] === 'function') {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return handle[pathname]();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;} else {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("No request handler found for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "404 Not found";</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.route = route;</td></tr>
									</table>
									<p>همان‌طور که می‌بینید، برای درخواست‌های که وجود ندارند و نمی‌توانند ره‌گیری شوند پیام 404 در نظر گرفته شده است.</p>
									<p>در آخر، سرور را بازنویسی خواهیم کرد تا بتواند با محتوایی که کنترلر به‌وسیله روتر برگشت داده به مرورگر پاسخ دهد. به شکل زیر:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>var url = require("url");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(route, handle) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pathname = url.parse(request.url).pathname;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request for " + pathname + " received.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var content = route(handle, pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(content);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>اگر برنامه بازنویسی شده را اجرا کنیم، خواهید دید که همه چیز به‌خوبی کار می‌کند: در مرورگر درخواست http://localhost:8888/start نتیجه "Hello Start" را برمی‌گرداند، درخواست http://localhost:8888/upload عبارت "Hello Upload" را نمایش می‌دهد و اگر خارج از این دو باشد عبارت "404 Not Found" تولید می‌شود.</p>
									<p>خوب پس چه مشکلی وجود دارد؟ پاسخ کوتاه: در زمان اجرا اگر یکی از کنترلرها نیاز به فرآیند non-blocking داشته باشد در آینده با مشکل مواجهه می‌شویم.</p>
									<p>در ادامه به پاسخ بلند خواهیم پرداخت.</p>
									<br>
									<h4 class="subhead--color">مسدود‌سازی و غیر مسدود‌سازی</h4>
									<p>همان‌طور که گفته شد، مشکلات زمانی ایجاد می‌شوند که یک کنترلر نیاز به فرآیند غیر مسدود‌سازی (non-blocking) داشته باشد اما اجازه دهید ابتدا در خصوص فرآیند مسدود‌سازی (blocking) صحبت کنیم و سپس فرآیند غیر مسدود‌سازی.</p>
									<p>قبل از توضیح دادن مبحث فوق، بررسی خواهیم کرد اگر یک فرآیند مسدود‌ساز به برنامه اضافه شود چه اتفاقی رخ خواهد داد.</p>
									<p>برای این کار باید در کنترلر start قبل از بازگشت دادن رشته "Hello World" یک تأخیر 10 ثانیه‌ای ایجاد شود. چون در جاوااسکریپت چیزی مانند sleep() وجود ندارد، از یک ترفند هوشمندانه‌تری استفاده خواهیم کرد.</p>
									<p>requestHandlers.js را به شکل زیر ویرایش کنید:</p>
									<table>
										<tr><td>function start() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function sleep(milliSeconds) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var startTime = new Date().getTime();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (new Date().getTime() < startTime + milliSeconds);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;sleep(10000);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;return "Hello Start";</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;return "Hello Upload";</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>در کد فوق واضح است که اگر تابع start() فراخوانی شود، Node.js 10 ثانیه صبر می‌کند و سپس عبارت "Hello World" را برگشت خواهد داد و زمانی که upload() فراخوانی شود بلافاصله محتوا را برگشت خواهد داد.</p>
									<p>بعد از ایجاد تغییرات سرور را restart کنید. اجازه دهید بررسی کنیم که چه اتفاقی خواهد افتاد: ابتدا در مرورگر دو تب یا پنجره باز کنید سپس در آدرس بار پنجره اول آدرس http://localhost:8888/start را وارد کنید اما صفحه را باز نکنید.</p>
									<p>در آدرس بار پنجره دوم آدرس http://localhost:8888/upload را وارد کنید و دوباره صفحه را باز نکنید.</p>
									<p>حال، به این صورت عمل کنید:‌ ابتدا در پنجره اول آدرس ("/start") را باز کنید سپس به‌سرعت به پنجره دوم بروید و آدرس ("/upload") را باز کنید.</p>
									<p>چه چیز را متوجه شدید: همان‌طور که انتظار داریم آدرس /start مدت 10 ثانیه زمان می‌برد تا بارگذاری شود و همچنین آدرس /upload مدت 10 ثانیه زمان می‌برد تا بارگذاری شود درصورتی‌که هیچ‌گونه تابع sleep() برای آن در نظر گرفته نشده است!</p>
									<p>چرا؟ به دلیل اینکه کنترلر start() دارای یک فرآیند مسدود‌ساز است. در حال حاضر در خصوص مدل اجرایی Node.js صحبت می‌کنیم که با ‌فٰرآیندهای سنگینی مشکل ندارند اما باید اهمیت بدهیم که فرآیند‌های دیگر Node.js با آن مسدود نشود و در عوض هرگاه ‌فٰرآیندهای سنگینی اجرا شوند باید در ‌پس‌زمینه برنامه قرار گیرند و رویداد‌های آن باید به‌وسیله حلقه رویداد (Event Loop) به کار گرفته شود.</p>
									<p>و متوجه شدیم که چرا روش فوق به ما اجازه استفاده از فرآیند غیر مسدود‌ساز در برنامه را نمی‌دهد.</p>
									<p>برای درک بهتر یک‌بار دیگر می‌خواهیم مستقیماً مشکل فوق را تجربه کنیم. برای این کار فایل requestHandlers.js را به شکل زیر ویرایش کنید:</p>
									<table>
										<tr><td>var exec = require("child_process").exec;</td></tr>
										<tr><td></td></tr>
										<tr><td>function start() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var content = "empty";</td></tr>
										<tr><td>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;exec("ls -lah", function (error, stdout, stderr) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content = stdout;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;return content;</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;return "Hello Upload";</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>مشاهده می‌کنید در کد فوق یک ماژول جدید از Node.js به نام child_process به برنامه اضافه شده است و به ما این امکان را می‌دهد که به‌راحتی در کنترلر از فرآیند غیر مسدود‌ساز استفاده کنیم: exec()</p>
									<p>exec() چه کاری انجام می‌دهد؟ می‌تواند داخل Node.js یک دستور Shell اجرا کند. در مثال فوق با استفاده از دستور ("ls -lah") فهرست تمام فایل‌های داخل پوشه جاری را دریافت می‌کنیم و این اجازه را به ما می‌دهد که این لیست را در آدرس /start که کاربر درخواست می‌کند نمایش دهیم.</p>
									<p>برنامه را اجرا و آدرس http://localhost:8888/start را باز کنید.</p>
									<p>صفحه به‌درستی بارگذاری شده است اما رشته "empty" نمایش داده می‌شود. چه مشکلی وجود دارد؟</p>
									<p>خوب، ممکن است حدس زده باشید، exec() به‌صورت خیلی سحرآمیز و سریع دستور "ls –lah" را انجام می‌دهد و ازاین‌رو ماژول مفیدی است چراکه می‌توانیم به‌وسیله آن دستورات سنگینی (کپی کردن فایل‌های سنگین) را اجرا کنیم بدون آن‌که برنامه را به‌صورت اجباری به‌عنوان یک مسدود‌ساز به حالت توقف کامل ببریم.</p>
									<p>(اگر مایل باشید دستور "ls –lah" را با دستور سنگین‌تر "find /" جایگزین کنیم).</p>
									<p>خوب، اجازه دهید کد را بازنویسی کنیم و بفهمیم که چرا ساختار فوق کار نمی‌کند.</p>
									<p>مشکل درون exec() است، برای اینکه یک non-blocking داشته باشیم باید از تابع کال‌بک استفاده کنیم. در مثال یک تابع بی‌نام که به‌عنوان پارامتر دوم از تابع exec() عبور داده شده که ریشه مشکل ما در آن نهفته است:</p>
									<table>
										<tr><td>function (error, stdout, stderr) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;content = stdout;</td></tr>
										<tr><td>}</td></tr>
									</table>
									<p>برنامه به‌صورت هم‌زمان (synchronous) اجراشدهاجراشده است به این معنی که بلافاصله پس از فراخوانی exec()، Node.js ادامه می‌دهد تا اطلاعات را بازگشت دهد. اینجاست که متغیر content هنوز رشته "empty" را در خود دارد و تابع کال‌بک عبور داده شده از exec() هنوز فراخوانی نشده است، با توجه به این واقعیت می‌توان گفت exec() نیز به‌صورت ناههم‌زمان اجراشده است.</p>
									<p>دستور “ls -lah” بسیار سبک و سریع است به همین دلیل تابع کال‌بک نسبتاً سریع فراخوانی می‌شود اما بااین‌وجود حالت ناهم‌زمان رخ می‌‌دهد.</p>
									<p>فکر کردن درباره یک دستور سنگین‌تر موضوع فوق را واضح‌تر می‌کند: برای این کار می‌توانیم از دستور "find /" استفاده کنیم که روی دستگاه من اجرای آن حدود 1 دقیقه طول می‌کشد. درصورتی‌که در کنترلر "ls –lah" را با "find /" جایگزین کنم و زمانی که آدرس /start را باز کنم بلافاصله یک پاسخ HTTP دریافت می‌شود که نشان می‌دهد exec() در ‌پس‌زمینه در حال انجام کاری است، با این اوصاف Node.js برنامه را ادامه می‌دهد‌ و تنها زمانی که دستور "find /" اجرایش به پایان رسیده باشد می‌توانیم فرض می‌کنیم که تابع کال‌بک عبور داده شده از exec() صدا زده خواهد شد.</p>
									<p>اما چگونه می‌توان به این هدف رسید، مانند نمایش دادن فهرستی از فایل‌ها در پوشه جاری به کاربر؟</p>
									<p>بعد از درک مباحث فوق می‌خواهیم در خصوص روش پاسخ دادن صحیح کنترلر به مرورگر صحبت کنیم.</p>
									<br>
									<h4 class="subhead--color">پاسخ دادن ناهم‌زمان به درخواست‌ها</h4>
									<p>قصد دارم از عبارت  "روش صحیح " استفاده کنم که خطرناک است چراکه اغلب تنها یک راه صحیح وجود ندارد؛ اما برای این مسئله باوجوداینکه در طول برنامه از توابع ناهم‌زمان استفاده می‌کنیم، فقط یک راه‌کار در Node.js ممکن است.</p>
									<p>در حال حاضر برنامه قادر است اطلاعات را از کنترلر به HTTP سرور به‌وسیله لایه‌های برنامه (کنترلر ← روتر ← سرور) انتقال دهد.</p>
									<p>روش جدیدی برای آن در نظر گرفته‌ایم: بجای هدایت اطلاعات به سرور، سرور را به سمت اطلاعات هدایت می‌کنیم، به‌صورت دقیق‌تر، می‌خواهیم شیء response را از طریق روتر به کنترلر تزریق کنیم، درنتیجه کنترلر قادر خواهد بود از توابع این شیء برای پاسخ دادن به درخواست‌ها استفاده کند.</p>
									<p>توضیح دادن کافی است، در زیر به‌صورت گام‌به‌گام تغییرات برنامه را متوجه خواهید شد، server.js را به شکل زیر ویرایش کنید:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>var url = require("url");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(route, handle) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pathname = url.parse(request.url).pathname;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request for " + pathname + " received.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;route(handle, pathname, response);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>به‌جای انتظار بازگشت یک مقدار از تابع route()، شی‌ء response را به‌عنوان پارامتر سوم عبور داده‌ایم. علاوه بر این، متدهای response را از تابع onRequest حذف کرده‌ایم چراکه الآن انتظار داریم route از این روش استفاده کند:</p>
									<table>
										<tr><td>function route(handle, pathname, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("About to route a request for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof handle[pathname] === 'function') {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle[pathname](response);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;} else {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("No request handler found for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(404, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("404 Not found");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>کد فوق همانند الگو مدنظر است: به‌جای انتظار بازگشت یک مقدار از کنترلر، شیء response را از آن عبور می‌دهیم.</p>
									<p>اگر مسیریاب برای درخواست نتواند هیچ کنترلری را پیدا کند، سعی می‌کنیم پاسخ 404 را برای مرورگر ارسال کنیم.</p>
									<p>و در آخر باید فایل requestHandlers.js را به شکل زیر ویرایش کرد:</p>
									<table>
										<tr><td>var exec = require("child_process").exec;</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;exec("ls -lah", function (error, stdout, stderr) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(stdout);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello Upload");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>تابع کنترلر نیاز دارد که پارامتر response را بپذیرد و از آن استفاده کند تا بتواند مستقیماً به درخواست پاسخ دهد.</p>
									<p>کنترلر start با استفاده از تابع کال‌بک درون exec() پاسخ را فراهم می‌کند و کنترلر upload هنوز رشته "Hello Upload" را نمایش می‌دهد اما این پاسخ را با استفاده از شیء response ارسال می‌کند</p>
									<p>با اجرای مجدد انتظار می‌رود برنامه به‌درستی کار کند (node index.js).</p>
									<p>اگر مایل باشید می‌توانید از یک دستور سنگین‌تری در /start استفاده کنید که نشان می‌دهد درخواست /upload مسدود نخواهد شد و بلافاصله نمایش داده می‌شود.</p>
									<p>به شکل زیر در requestHandlers.js تغییرات زیر را اعمال کنید:</p>
									<table>
										<tr><td>var exec = require("child_process").exec;</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;exec("find /",</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ timeout: 10000, maxBuffer: 20000*1024 },</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function (error, stdout, stderr) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(stdout);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello Upload");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>در کد فوق درخواست HTTP برای http://localhost:8888/start ۱۰ ثانیه طول خواهد کشید تا بارگذاری شود اما درخواست http://localhost:8888/upload بلافاصله پاسخ داده می‌شود حتی اگر /start هنوز در حال پردازش باشد.</p>
									<br><br>
                                    <h3 class="head--color">یک گام به جلو</h3>
									<p>تابه‌حال، تمامی کارهایی که انجام شده است بسیار خوب و زیبا هستند؛ اما در حقیقت ارزشی برای کاربر قائل نبوده‌ایم.</p>
									<p>سرور، روتر و کنترلر‌ها درجای خود قرار دارند بنابراین الآن می‌توانیم قسمت محتوا (content) را برای سایت در نظر بگیریم و به کاربران این اجازه را بدهیم که با برنامه تعامل داشته باشند و بتوانند با انتخاب فایل موردنظر اقدام به آپلود کنند و سپس فایل آپلود شده را در مرورگر خود مشاهده کنند. به‌منظور ساده‌تر کردن فرآیند آپلود فرض خواهیم کرد که کاربر فقط بتواند تصاویر را آپلود و مشاهده کند.</p>
									<p>در قدم اول نگاه خواهیم کرد که چگونه درخواست‌های ورودی POST را کنترل کنیم و در قدم دوم با استفاده از یک ماژول خارجی Node.js فرآیند آپلود فایل را کنترل می‌کنیم. این روش را به دو دلیل انتخاب کرده‌ام.</p>
									<ul>
										<li>کنترل کردن درخواست‌های POST نسبتاً با Node.js ساده است، ولی شاید تا به اینجا آموختن کافی باشد اما ارزش تمرین بیشتر را دارد.</li>
										<li>کنترل کردن آپلود فایل (مانند درخواست‌های چند بخشه POST) در Node.js ساده نیست و بنابراین باید فراتر از محدوده این کتاب قدم برداریم و می‌توانیم برای این آموزش از یک ماژول خارجی استفاده کنیم.</li>
									</ul>
									<br><br>
                                    <h3 class="head--color">مدیریت درخواست‌های POST</h3>
									<p>بیاید ساده به این موضوع نگاه کنیم: یک فیلد textarea را در نظر می‌گیریم که کاربر می‌تواند آن را پر کند و با یک درخواست POST آن را برای سرور ارسال کند. پس از دریافت و رسیدگی به این درخواست، برنامه موظف است اطلاعات درون textarea را نمایش دهد.</p>
									<p>برای استفاده از این فرم نیاز داریم که در فایل requestHandlers.js بر روی کنترلر /start تغییراتی را به شکل زیر اعمال کنیم:</p>
									<table>
										<tr><td>function start(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var body = &#39;&lt;html&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;head&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;charset=UTF-8&quot; /&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/head&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;body&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/form&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/body&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/html&gt;&#39;;</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write(body);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("Hello Upload");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>باید با باز کردن آدرس http://localhost:8888/start فرم را مشاهده کنید، در غیر این صورت اگر فرمی وجود نداشت برنامه را restart کنید.</p>
									<p>اگر فکر می‌کنید که کدهای کنترلر زیبایی کافی را ندارند و زشت هستند باید گفت که در این آموزش تصمیم گرفته‌ام که سطح اضافی (جدا کردن view از controller) به برنامه اضافه نشود چراکه مبحث خاصی برای ما در زمینه آموزش جاوااسکریپت و Node.js نخواهد بود.</p>
									<p>حال که به یک تازه‌کار پیشرفته تبدیل شده‌ایم نباید از این واقعیت تعجب کنیم که چگونه به‌وسیله توابع کال‌بک غیر مسدود‌ساز، داده‌های (data) یک درخواست POST را به شکل ناهم‌زمان کنترل کنیم.</p>
									<p>شاید حس کنید که درخواست‌های POST می‌توانند پتانسیل سنگین بودن را داشته باشند به این دلیل که هیچ‌چیز کاربر را از وارد کردن اطلاعات متوقف نمی‌کند و در این حال درخواست‌ها می‌توانند حجم‌های مگابایتی داشته باشند. رسیدگی به طیف مختلفی از داده‌ها در یک فرآیند ممکن است نتیجه آن فرآیند مسدود‌ساز باشد.</p>
									<p>برای اینکه فرآیند غیر مسدود‌ساز داشته باشیم، Node.js این امکان را می‌دهد که داده‌های یک درخواست POST را به قطعات مختلفی تقسیم کنیم و توابع کال‌بک را به رویداد‌های خاصی اختصاص دهیم و فراخوانی کنیم. این رویدادها شامل رویداد داده (یک قطعه جدید از POST می‌رسد) و پایان (تمامی قطعه‌ها دریافت شده‌اند) هستند.</p>
									<p>نیاز داریم به Node.js بگوییم، زمانی که رویدادها رخ می‌دهند کدام توابع کال‌بک را صدا بزند. این کار در صورتی امکان‌پذیر است که به شیء request، شنود (listeners) اضافه کنیم و هر زمان که یک درخواست HTTP دریافت می‌شود تابع کال‌بک عبور داده شده از onRequest را صدا بزند.</p>
									<p>که می‌تواند به شکل زیر باشید:</p>
									<table>
										<tr><td>request.addListener("data", function(chunk) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;// called when a new chunk of data was received</td></tr>
										<tr><td>});</td></tr>
										<tr><td></td></tr>
										<tr><td>request.addListener("end", function() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;// called when all chunks of data have been received</td></tr>
										<tr><td>});</td></tr>
									</table>
									<p>در پیاده‌سازی مفهوم فوق سؤال‌هایی مطرح هستند. در حال حاضر فقط در سرور می‌توانیم به شیء request دسترسی داشته باشیم و آن را از روتر و کنترلر عبور نمی‌دهیم، همانند کاری که با شیء response صورت گرفت.</p>
									<p>به نظر من، کار یک HTTP سرور در برنامه گرفتن تمامی اطلاعات از درخواستی است که نیاز دارد بر روی آن کاری انجام شود؛ بنابراین پیشنهاد می‌کنم در سرور داده‌های POST پردازش شوند و بعد داده نهایی را به داخل روتر و کنترلر عبور دهیم که درنهایت می‌توان تصمیم گرفت چه کاری بر روی آن‌ها صورت گیرد.</p>
									<p>بنابراین ایده این است که توابع کال‌بک data و end را در سرور قرار دهیم و تمامی قطعات داده POST را تا زمانی که داده‌ها به داخل روتر و سپس به کنترلر عبور داده شوند در تابع کال‌بک data جمع‌آوری کنیم و زمانی که داده‌ها دریافت شد تابع route را در end صدا بزنیم.</p>
									<p>ابتدا باید فایل server.js را به شکل زیر بازنویسی کرد:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>var url = require("url");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(route, handle) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var postData = "";</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pathname = url.parse(request.url).pathname;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request for " + pathname + " received.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.setEncoding("utf8");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.addListener("data", function(postDataChunk) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postData += postDataChunk;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Received POST data chunk '"+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postDataChunk + "'.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.addListener("end", function() {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;route(handle, pathname, response, postData);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>به صورتی کلی در قطعه کد بالا سه کار صورت می‌گیرد که منجر می‌شود بتوانیم از داده‌ها در کنترلر‌ها استفاده کنیم: ابتدا، تعریف می‌کنیم که انتظار برود داده‌هایی که دریافت می‌شوند ساختار UTF-8 داشته باشند همچنین یک شنونده رویداد به نام "data" اضافه کرده‌ایم که در آن، وقتی‌که یک قطعه جدید از داده‌های POST فرا می‌رسد مرحله‌به‌مرحله مقدار متغیر postData تازه و بروز می‌شود و زمانی که تمامی اطلاعات جمع‌آوری شدند با استفاده از تابع کال‌بک end اطلاعات را به داخل router انتقال می‌دهیم.</p>
									<p>اضافه کردن ثبت گزارش در خط فرمان برای هر قطعه‌ای که دریافت می‌شود ممکن است ایده جالبی نباشد؛ اما در فصل بعدی به‌صورت جزئی این موضوع را بررسی خواهیم کرد.</p>
									<p>اجازه دهید برنامه را جذاب‌تر کنیم، در صفحه /upload می‌خواهیم محتوای دریافتی را نمایش دهیم. برای این کار نیاز داریم که متغیر postData را به کنترلر ببریم. باید فایل router.js را به شکل زیر بازنویسی کرد:</p>
									<table>
										<tr><td>function route(handle, pathname, response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("About to route a request for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof handle[pathname] === 'function') {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle[pathname](response, postData);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;} else {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("No request handler found for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(404, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("404 Not found");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.route = route;</td></tr>
									</table>
									<p>و در requestHandlers.js باید ایجاب کنیم که کنترلر upload بتواند محتوا را نمایش دهد:</p>
									<table>
										<tr><td>function start(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var body = &#39;&lt;html&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;head&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;charset=UTF-8&quot; /&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/head&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;body&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/form&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/body&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/html&gt;&#39;;</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(body);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("You've sent: " + postData);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>همین بود، حال قادر هستیم داده‌های POST را دریافت و در کنترلر‌ها استفاده کنیم.</p>
									<p>نکته‌ای در این مبحث وجود دارد: آنچه از روتر و کنترلر‌ها عبور داده شد، بدنه  کامل درخواست POST بود. احتمال دارد بخواهیم در اینجا از فیلد‌های فرم که درخواست POST را کامل می‌کنند استفاده کنیم ازاین‌رو می‌توانیم به فیلد text اشاره کنیم که در قطعه کد زیر به کار گرفته شده است.</p>
									<p>در فصول قبل در خصوص ماژول querystring صحبت کردیم که به شکل زیر به ما کمک می‌کند:</p>
									<table>
										<tr><td>var querystring = require("querystring");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var body = &#39;&lt;html&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;head&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;charset=UTF-8&quot; /&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/head&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;body&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/form&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/body&gt;&#39;+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;&lt;/html&gt;&#39;;</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(body);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("You've sent the text: "+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;querystring.parse(postData).text);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
									</table>
									<p>همه چیز در خصوص بارگیری و تخلیه داده‌های POST توضیح داده شد و برای یک آموزش ابتدایی تا به اینجا بسیار عالی است.</p>
									<br><br>
                                    <h3 class="head--color">مدیریت فایل‌ها</h3>
									<p>این فصل به ما کمک می‌کند که روش نصب کتابخانه‌های خارجی در Node.js و استفاده آن‌ها در داخل کدها را فرا بگیریم.</p>
									<p>در اهداف برنامه، کاربران این اجازه را داشتند که اقدام به آپلود فایل تصویری و نمایش آن در مرورگر کنند. قصد داریم از یک ماژول خارجی (External) برای مدیریت فایل‌ها استفاده کنیم که node-formidable نام دارد و توسط Felix Geisendoerfer نوشته شده است که به‌خوبی تمامی اطلاعات فایل را تجزیه می‌کند. مدیریت فایل‌ها  "تنها " اشاره به همان مدیریت داده‌های POST می‌کند که استفاده از راه‌حل آماده فوق حس خیلی خوبی ایجاد می‌کند.</p>
									<p>برای استفاده از کدهای Felix باید اقدام به نصب ماژول کنیم، برای این منظور می‌توانیم از مدیر بسته‌های Node که به‌اختصار NPM نامیده می‌شود استفاده کنیم و ماژول خارجی را نصب کنیم.</p>
									<p>برای این کار دستور زیر را در خط فرمان وارد کنید:</p>
									<table>
										<tr><td>npm install formidable</td></tr>
									</table>
									<p>اگر در خط فرمان نتیجه مشابه زیر بود:</p>
									<table>
										<tr><td>formidable@*.*.* node_modules\formidable</td></tr>
									</table>
									<p>ماژول به‌خوبی نصب شده است و می‌توانید از آن استفاده کنید.</p>
									<p>حال کافی است به شکل زیر ماژول formidable به برنامه اضافه شود:</p>
									<table>
										<tr><td>var formidable = require("formidable");</td></tr>
									</table>
									<p>اصطلاح formidable برای فرمی به کار می‌رود که به‌وسیله HTTP POST ارسال شده است و در Node.js قابل استفاده است. تمام چیزی که نیاز داریم ساخت یک فرم ورودی است که درنهایت بتوانیم به‌وسیله شیء request در HTTP سرور به فیلدها و فایل‌های ارسال شده توسط این فرم دسترسی پیدا کنیم.</p>
									<p>کد زیر به‌عنوان مثالی از یک پروژه node-formidable است که تعامل قسمت‌های مختلف را نمایش می‌دهد:</p>
									<table>
										<tr><td>var formidable = require('formidable'),</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http = require('http'),</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;sys = require('sys');</td></tr>
										<tr><td></td></tr>
										<tr><td>http.createServer(function(req, res) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;if (req.url == '/upload' && req.method.toLowerCase() == 'post') {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// parse a file upload</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var form = new formidable.IncomingForm();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;form.parse(req, function(error, fields, files) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.writeHead(200, {'content-type': 'text/plain'});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.write('received upload:\n\n');</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.end(sys.inspect({fields: fields, files: files}));</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;// show a file upload form</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;res.writeHead(200, {'content-type': 'text/html'});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;res.end(</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;form action="/upload" enctype="multipart/form-data" '+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'method="post"&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="text" name="title"&gt;&lt;br&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="file" name="upload" multiple="multiple"&gt;&lt;br&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="submit" value="Upload"&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/form&gt;'</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;);</td></tr>
										<tr><td>}).listen(8888);</td></tr>
									</table>
									<p>اگر کد فوق را در یک فایل قرار دهیم و سپس آن را اجرا کنیم، یک فرم را مشاهده خواهیم کرد که می‌توانیم در آن اقدام به آپلود فایل کنیم و اطلاعات فایل را در خط فرمان مشاهده کنیم که درنهایت خروجی زیر را تولید می‌کند:</p>
									<table>
										<tr><td>received upload:</td></tr>
										<tr><td></td></tr>
										<tr><td>{&nbsp;fields: {&nbsp;title:&nbsp;'Hello World'&nbsp;},</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;files:</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;upload:</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;size:&nbsp;1558,</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path: '/tmp/1c747974a27a6292743669e91f29350b',</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: 'us-flag.png',</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: 'image/png',</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_writeStream: [Object],</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length: [Getter],</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename: [Getter],</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mime: [Getter] } } }</td></tr>
									</table>
									<p>به‌منظور استفاده از این حالت آنچه نیاز داریم، اضافه کردن حالت منطقی formidable به ساختار برنامه است به‌علاوه باید متوجه باشیم که هنگام درخواست نمایش از طرف مرورگر چگونه از فایل‌های آپلودی استفاده کنیم.</p>
									<p>ابتدا به مسئله دوم می‌پردازیم و سپس اولی:‌ اگر یک فایل بر روی هارد دیسک محلی وجود داشته باشد، چگونه برای یک درخواست سمت مرورگر از آن استفاده کنیم؟</p>
									<p>جای تعجب نیست، ماژول پیش‌فرضی برای این کار وجود دارد به نام fs که به‌وضوح این کمک را می‌کند که  به‌وسیله سرور اقدام به خواندن محتوای فایل می‌کنیم.</p>
									<p>اجازه دهید یک کنترلر برای آدرس /show ایجاد کنیم که به ما کمک می‌کند فایل /tmp/test.png را نمایش دهیم. البته در ابتدا شاید فکر کنید در حال ذخیره‌سازی یک فایل PNG واقعی هستیم.</p>
									<p>(نکته: پوشه‌ای در کنار سایر فایل‌های برنامه با عنوان tmp ایجاد کنید سپس تصویری با عنوان test.png در پوشه قرار دهید.)</p>
									<p>فایل requestHandlers.js را به شکل زیر ویرایش کنید:</p>
									<table>
										<tr><td>var querystring = require("querystring"), fs = require("fs");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var body = '&lt;html&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;head&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;meta http-equiv="Content-Type" '+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'content="text/html; charset=UTF-8" /&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/head&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;body&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;form action="/upload" method="post"&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="submit" value="Submit text" /&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/form&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/body&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/html&gt;';</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(body);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("You've sent the text: "+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;querystring.parse(postData).text);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function show(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'show' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "image/png"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;fs.createReadStream("/tmp/test.png").pipe(response);</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
										<tr><td>exports.show = show;</td></tr>
									</table>
									<p>همچنین نیاز داریم کنترلر جدید را به فایل index.js اضافه کنیم:</p>
									<table>
										<tr><td>var server = require("./server");</td></tr>
										<tr><td>var router = require("./router");</td></tr>
										<tr><td>var requestHandlers = require("./requestHandlers");</td></tr>
										<tr><td></td></tr>
										<tr><td>var handle = {}</td></tr>
										<tr><td>handle["/"] = requestHandlers.start;</td></tr>
										<tr><td>handle["/start"] = requestHandlers.start;</td></tr>
										<tr><td>handle["/upload"] = requestHandlers.upload;</td></tr>
										<tr><td>handle["/show"] = requestHandlers.show;</td></tr>
										<tr><td></td></tr>
										<tr><td>server.start(router.route, handle);</td></tr>
									</table>
									<p>با راه‌اندازی مجدد سرور (restart) و باز کردن آدرس http://localhost:8888/show در مرورگر، فایل ذخیره شده در /tmp/test.png باید نمایش داده شده باشد.</p>
									<p>بسیار خوب، همه مراحلی که تا اتمام برنامه باید انجام دهیم:</p>
									<ul>
										<li>ایجاد فرمی در کنترلر start برای آپلود کردن فایل</li>
										<li>افزودن node-formidable به کنترلر upload و ذخیره کردن فایل آپلودی در /tmp/test.png</li>
										<li>قرار دادن تصویر آپلود شده در خروجی HTML به‌وسیله آدرس /upload</li>
									</ul>
									<p>مرحله اول ساده است. نیاز داریم که رمزگذاری multipart/form-data را به فرم HTML اضافه کنیم سپس فیلد textarea را حذف و یک فیلد آپلود فایل به فرم اضافه می‌کنیم و در آخر عنوان دکمه submit را به "Upload File" تغییر می‌دهیم، فایل requestHandlers.js را به شکل زیر ویرایش کنید:</p>
									<table>
										<tr><td>var querystring = require("querystring"), fs = require("fs");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var body = '&lt;html&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;head&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;meta http-equiv="Content-Type" '+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'content="text/html; charset=UTF-8" /&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/head&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;body&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;form action="/upload" enctype="multipart/form-data" '+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'method="post"&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="file" name="upload"&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="submit" value="Upload file" /&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/form&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/body&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/html&gt;';</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(body);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response, postData) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/plain"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.write("You've sent the text: "+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;querystring.parse(postData).text);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function show(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'show' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "image/png"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;fs.createReadStream("/tmp/test.png").pipe(response);</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
										<tr><td>exports.show = show;</td></tr>
									</table>
									<p>بسیار عالی، مرحله بعدی مقدار پیچیده‌تر است. مشکل اول: می‌خواهیم از فایل آپلود شده در کنترلر upload استفاده کنیم. نیاز داریم شیء request را از form.parse عبور دهیم.</p>
									<p>اما در حال حاضر فقط شیء response و آرایه postData را داریم. به نظر می‌رسد باید شیء request را از مسیر سرور به روتر و سپس به کنترلر انتقال دهیم. ممکن است راه‌حل‌های بهتری وجود داشته باشد اما این روش در حال حاضر به‌خوبی به ما کمک می‌کند.</p>
									<p>برای آپلود فایل نیازی به آرایه postData نداریم و می‌توانیم آن را از سرور و کنترلر حذف کنیم؛ اما هنوز مشکل بزرگ‌تری وجود دارد: ما در حال حاضر از رویداد‌های data شیء request در سرور استفاده می‌کنیم به این معناست که form.parse هنوز نیاز به استفاده از آن رویداد‌ها دارد و ممکن است اطلاعات زیادی از آن‌ها دریافت نکند (Node.js از میانگیر (buffer) برای هیچ داده‌ای استفاده نمی‌کند).</p>
									<p>با فایل server.js شروع خواهیم کرد – ابتدا خط request.setEncoding و postData و را از آن حذف می‌کنیم و به‌جای آن شیء request را به داخل router عبور می‌دهیم:</p>
									<table>
										<tr><td>var http = require("http");</td></tr>
										<tr><td>var url = require("url");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(route, handle) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;function onRequest(request, response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pathname = url.parse(request.url).pathname;</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request for " + pathname + " received.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;route(handle, pathname, response, request);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;http.createServer(onRequest).listen(8888);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Server has started.");</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
									</table>
									<p>ما به postData نیاز نداریم و به‌جای آن شیء request را عبور می‌دهیم و باید در router.js تغییراتی ایجاد کنیم:</p>
									<table>
										<tr><td>function route(handle, pathname, response, request) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("About to route a request for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof handle[pathname] === 'function') {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle[pathname](response, request);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;} else {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("No request handler found for " + pathname);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(404, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("404 Not found");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.route = route;</td></tr>
									</table>
									<p>اکنون می‌توانیم از شیء request در کنترلر upload استفاده کنیم و ماژول formidable به اطلاعات فایلی که در حال ذخیره شدن در پوشه /tmp است رسیدگی خواهد کرد، اما نیاز داریم که فایل را به test.png تغییر نام دهیم. بله می‌خواهیم همه چیز را ساده نگه‌داریم و فرض کنیم تصویر PNG آپلود شده است.</p>
									<p>در منطق تغییر نام مقداری پیچیدگی اضافی وجود دارد: پیاده‌سازی Node در سیستم‌عامل ویندوز مشابه باقی سیستم‌عامل‌ها نیست، زمانی که سعی کنید نام یک فایل را تغییر دهید و یک فایل با نام مشابه فایل جدید وجود داشته باشد موجب رخ دادن خطا می‌شود به همین دلیل باید برای رفع این خطا، فایل را حذف کنیم.</p>
									<table>
										<tr><td>var querystring = require("querystring"),</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;fs = require("fs"),</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;formidable = require("formidable");</td></tr>
										<tr><td></td></tr>
										<tr><td>function start(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'start' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var body = '&lt;html&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;head&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;meta http-equiv="Content-Type" '+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'content="text/html; charset=UTF-8" /&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/head&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;body&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;form action="/upload" enctype="multipart/form-data" '+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'method="post"&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="file" name="upload"&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;input type="submit" value="Upload file" /&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/form&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/body&gt;'+</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'&lt;/html&gt;';</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write(body);</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function upload(response, request) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'upload' was called.");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;var form = new formidable.IncomingForm();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;console.log("about to parse");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;form.parse(request, function(error, fields, files) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("parsing done");</td></tr>
										<tr><td></td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;/* Possible error on Windows systems:</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tried to rename to an already existing file */</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.rename(files.upload.path, "/tmp/test.png", function(err) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.unlink("/tmp/test.png");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.rename(files.upload.path, "/tmp/test.png");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "text/html"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("received image:&lt;br/&gt;");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.write("&lt;img src='/show' /&gt;");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end();</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;});</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>function show(response) {</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Request handler 'show' was called.");</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.writeHead(200, {"Content-Type": "image/png"});</td></tr>
										<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.createReadStream("/tmp/test.png").pipe(response);</td></tr>
										<tr><td>}</td></tr>
										<tr><td></td></tr>
										<tr><td>exports.start = start;</td></tr>
										<tr><td>exports.upload = upload;</td></tr>
										<tr><td>exports.show = show;</td></tr>
									</table>
									<p>همین بود، سرور را مجدداً راه‌اندازی (restart) کنید و یک فایل تصویری PNG از هارد دیسک محلی انتخاب کنید و سپس اقدام به آپلود کنید. درنهایت مشاهده می‌کنید که فایل در صفحه‌نمایش داده خواهد شد.</p>

								</div>
                            </div>
                        </div>
                    </div>
                    <div class="bb-item" id="item8">
                        <div class="content">
                            <div class="scroller">
                                <h2>نتیجه گیری و چشم انداز</h2>
                                <div class="page">
									<p>تبریک، مأموریت ما انجام شد! توانستیم به کمک Node.js یک برنامه تحت وب ساده اما کامل بنویسیم. در این کتاب در خصوص جاوااسکریپت در سمت سرور، برنامه‌نویسی تابعی، مسدود‌سازی و غیر مسدود‌سازی فرآیند‌ها، توابع Callback، رویداد‌ها، ماژول‌های داخلی و خارجی و خیلی بیشتر صحبت کردیم.</p>
									<p>البته مباحثی دیگری هم وجود داشتند که صحبت نکردیم: درباره پایگاه‌های داده، نوشتن و کار با واحد‌های آزمایش (Unit Test)، ساخت ماژول‌های خارجی و قابل نصب به‌وسیله NPM و حتی موارد ساده‌ای مثل کنترل درخواست‌های GET.</p>
									<p>اما هدف این کتاب افراد مبتدی بوده و نمی‌توان درباره موضوعات یک‌به‌یک بحث کرد.</p>
								</div>
                            </div>
                        </div>
                    </div>
                </div>

                <nav>
                    <span id="bb-nav-prev">&larr;</span>
                    <span id="bb-nav-next">&rarr;</span>
                </nav>

                <span id="tblcontents" class="menu-button">فهرست مطالب</span>

            </div>

        </div><!-- /container -->
        <script src="js/jquery.min.js"></script>
        <script src="js/jquery.mousewheel.js"></script>
        <script src="js/jquery.jscrollpane.min.js"></script>
        <script src="js/jquerypp.custom.js"></script>
        <script src="js/jquery.bookblock.js"></script>
        <script src="js/page.js"></script>
        <script>
            $(function() {

                Page.init();

            });
        </script>
    </body>
</html>